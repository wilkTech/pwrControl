<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>PowerControl Dashboard - Sterowanie Przeka≈∫nikami, Komputerami i Proxmox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png?v=3">
  <style>
    /* ========== CSS Variables ========== */
    :root {
      --bg: #121212;
      --fg: #E0E0E0;
      --card: #1E1E1E;
      --header: #2C2C2C;
      --primary: #6200EE;
      --primary-hover: #3700B3;
      --accent: #03DAC6;
      --muted: #555555;
      --border: #333333;
      --purple: #BB86FC;
      --success: #1b5e20;
      --warning: #37474f;
      --error: #b71c1c;
      --secondary: #455a64;
      --mid: #263238;
      --online: #4caf50;
      --offline: #f44336;
      --unknown: #9e9e9e;
      
      /* Spacing */
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 12px;
      --spacing-lg: 16px;
      --spacing-xl: 20px;
      --spacing-xxl: 40px;
      
      /* Border radius */
      --radius-sm: 4px;
      --radius-md: 6px;
      --radius-lg: 8px;
      --radius-pill: 999px;
      
      /* Shadows */
      --shadow-light: 0 2px 4px rgba(0, 0, 0, 0.1);
      --shadow-medium: 0 4px 8px rgba(0, 0, 0, 0.2);
      --shadow-heavy: 0 8px 16px rgba(0, 0, 0, 0.3);
      --shadow-toast: 0 4px 16px rgba(0, 0, 0, 0.4);
      
      /* Transitions */
      --transition-fast: 0.15s ease;
      --transition-normal: 0.25s ease;
      --transition-slow: 0.3s ease;
    }

    /* ========== Base Styles ========== */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--fg);
      margin: var(--spacing-xl);
      line-height: 1.5;
      font-size: 14px;
    }

    /* ========== Typography ========== */
    h1 {
      text-align: center;
      color: var(--purple);
      margin: var(--spacing-xxl) 0 var(--spacing-xl) 0;
      font-size: 1.8rem;
      font-weight: 600;
      letter-spacing: -0.5px;
    }

    h1:first-child {
      margin-top: 0;
    }

    /* ========== Layout Components ========== */
    .table-container {
      overflow-x: auto;
      margin: var(--spacing-xl) 0;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-medium);
      background: var(--card);
    }

    .center {
      text-align: center;
      margin-top: var(--spacing-xl);
    }

    .manual-section {
      margin-top: var(--spacing-xxl);
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    /* ========== Performance Warning ========== */
    .performance-warning {
      background: var(--warning);
      color: #ffffff;
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      margin: var(--spacing-md) 0;
      text-align: center;
      font-size: 0.85rem;
      display: none; /* Hidden by default, shown when multiple tabs detected */
    }

    .performance-warning.show {
      display: block;
    }

    .visibility-status {
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--mid);
      color: var(--fg);
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      z-index: 1001;
      display: none;
    }

    .visibility-status.paused {
      background: var(--warning);
      color: #ffffff;
      display: block;
    }

    /* ========== Tables ========== */
    table {
      width: 100%;
      border-collapse: collapse;
      background: var(--card);
      min-width: 600px;
    }

    th, td {
      border: 1px solid var(--border);
      padding: var(--spacing-md);
      text-align: center;
      vertical-align: middle;
    }

    th {
      background: var(--header);
      color: var(--purple);
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    td {
      background: var(--card);
      transition: background-color var(--transition-fast);
    }

    tr:hover td {
      background: color-mix(in srgb, var(--card) 90%, var(--accent) 10%);
    }

    /* ========== Buttons ========== */
    button {
      padding: 10px 15px;
      margin: var(--spacing-xs);
      font-size: 14px;
      font-weight: 500;
      color: #ffffff;
      background: var(--primary);
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-slow);
      position: relative;
      overflow: hidden;
    }

    button:hover:not(:disabled) {
      background: var(--primary-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-light);
    }

    button:active:not(:disabled) {
      background: var(--accent);
      color: #000000;
      transform: translateY(0);
    }

    button:disabled {
      background: var(--muted);
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      box-shadow: none;
    }

    button.secondary {
      background: var(--secondary);
    }

    button.secondary:hover:not(:disabled) {
      background: color-mix(in srgb, var(--secondary) 80%, white 20%);
    }

    button.ghost {
      background: transparent;
      color: var(--fg);
      border: 1px solid var(--border);
    }

    button.ghost:hover:not(:disabled) {
      background: var(--border);
      border-color: var(--accent);
    }

    button.small {
      font-size: 12px;
      padding: var(--spacing-xs) var(--spacing-sm);
    }

    /* ========== Specialized Buttons ========== */
    .notify-btn {
      padding: var(--spacing-xs) 10px;
      font-size: 12px;
      border-radius: var(--radius-md);
      font-weight: 500;
      transition: all var(--transition-normal);
    }

    .notify-on {
      background: #00695c;
      color: #ffffff;
    }

    .notify-on:hover:not(:disabled) {
      background: #004d40;
    }

    .notify-off {
      background: #424242;
      color: #ffffff;
    }

    .notify-off:hover:not(:disabled) {
      background: #616161;
    }

    .ping-btn {
      background: var(--muted);
      border: none;
      border-radius: var(--radius-sm);
      padding: var(--spacing-xs);
      font-size: 11px;
      cursor: pointer;
      color: var(--fg);
      transition: all var(--transition-fast);
      min-width: 60px;
    }

    .ping-btn.pinging {
      background: var(--warning);
      color: #ffffff;
    }

    .ping-btn.online {
      background: var(--online);
      color: #ffffff;
    }

    .ping-btn.offline {
      background: var(--offline);
      color: #ffffff;
    }

    /* ========== Badges ========== */
    .badge {
      display: inline-block;
      border-radius: var(--radius-pill);
      padding: 0.25rem 0.6rem;
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .badge.on {
      background: var(--success);
      color: #ffffff;
    }

    .badge.off {
      background: #424242;
      color: #ffffff;
    }

    .badge.running {
      background: var(--success);
      color: #ffffff;
    }

    .badge.stopped {
      background: #424242;
      color: #ffffff;
    }

    .badge.paused {
      background: var(--warning);
      color: #ffffff;
    }

    .badge.error {
      background: var(--error);
      color: #ffffff;
    }

    .badge.online {
      background: var(--online);
      color: #ffffff;
    }

    .badge.offline {
      background: var(--error);
      color: #ffffff;
    }

    .badge.unknown {
      background: var(--unknown);
      color: #ffffff;
    }

    /* ========== Status Indicators ========== */
    .status-cell {
      position: relative;
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: var(--spacing-sm);
    }

    .status-indicator.on {
      background: var(--success);
      box-shadow: 0 0 4px var(--success);
    }

    .status-indicator.off {
      background: #424242;
    }

    .status-indicator.online {
      background: var(--online);
      box-shadow: 0 0 4px var(--online);
      animation: pulse 2s infinite;
    }

    .status-indicator.offline {
      background: var(--error);
    }

    .status-indicator.unknown {
      background: var(--unknown);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* ========== IP Display ========== */
    .ip-list {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-xs);
      justify-content: center;
      align-items: center;
    }

    .ip-chip {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-xs);
      background: var(--mid);
      border: 1px solid var(--border);
      border-radius: var(--radius-pill);
      padding: var(--spacing-xs) var(--spacing-sm);
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent);
    }

    .ip-btn {
      background: transparent;
      border: 1px solid var(--secondary);
      border-radius: var(--radius-sm);
      padding: 2px var(--spacing-xs);
      font-size: 11px;
      cursor: pointer;
      color: var(--fg);
      transition: all var(--transition-fast);
    }

    .ip-btn:hover:not(:disabled) {
      background: var(--secondary);
      color: #ffffff;
    }

    /* ========== Form Elements ========== */
    textarea {
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--border);
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      width: 100%;
      max-width: 600px;
      font-size: 14px;
      resize: vertical;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      line-height: 1.4;
      transition: border-color var(--transition-normal);
    }

    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(98, 0, 238, 0.2);
    }

    /* ========== Toast Notifications ========== */
    #toast {
      position: fixed;
      right: var(--spacing-lg);
      bottom: var(--spacing-lg);
      background: var(--mid);
      color: #ffffff;
      padding: var(--spacing-md) var(--spacing-lg);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-toast);
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition-normal);
      z-index: 1000;
      max-width: 300px;
      word-wrap: break-word;
    }

    #toast.show {
      opacity: 1;
    }

    /* ========== Loading States ========== */
    .loading {
      position: relative;
      color: transparent;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 16px;
      height: 16px;
      margin: -8px 0 0 -8px;
      border: 2px solid var(--border);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ========== Responsive Design ========== */
    @media (max-width: 768px) {
      body {
        margin: 10px;
        font-size: 13px;
      }
      
      h1 {
        font-size: 1.5em;
        margin: var(--spacing-xl) 0 var(--spacing-lg) 0;
      }
      
      th, td {
        padding: var(--spacing-sm);
        font-size: 12px;
      }
      
      button {
        padding: var(--spacing-sm) 10px;
        font-size: 12px;
        margin: 2px;
      }
      
      table {
        min-width: unset;
      }
      
      textarea {
        font-size: 12px;
        padding: var(--spacing-sm);
      }
      
      .table-container {
        margin: var(--spacing-md) 0;
      }
    }

    @media (max-width: 480px) {
      body {
        margin: var(--spacing-xs);
      }
      
      h1 {
        font-size: 1.2em;
      }
      
      /* Mobile table transformation */
      table, thead, tbody, th, td, tr {
        display: block;
      }
      
      thead tr {
        position: absolute;
        top: -9999px;
        left: -9999px;
      }
      
      tr {
        border: 1px solid var(--border);
        border-radius: var(--radius-md);
        margin-bottom: var(--spacing-md);
        padding: var(--spacing-sm);
        background: var(--card);
      }
      
      td {
        border: none;
        border-bottom: 1px solid var(--border);
        position: relative;
        padding-left: 50%;
        text-align: right;
        padding-top: var(--spacing-sm);
        padding-bottom: var(--spacing-sm);
      }
      
      td:last-child {
        border-bottom: none;
      }
      
      td::before {
        content: attr(data-label) ": ";
        position: absolute;
        left: var(--spacing-sm);
        width: 45%;
        padding-right: 10px;
        white-space: nowrap;
        font-weight: bold;
        text-align: left;
        color: var(--purple);
      }
      
      .center {
        margin-top: 10px;
      }
      
      textarea {
        font-size: 11px;
        padding: var(--spacing-xs);
      }
      
      .ip-list {
        justify-content: flex-end;
      }
      
      button {
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 11px;
        margin: 1px;
      }
    }

    /* ========== Accessibility ========== */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* ========== Focus Styles ========== */
    button:focus-visible,
    textarea:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    /* ========== Dark Mode Enhancements ========== */
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f5f5f5;
        --fg: #212121;
        --card: #ffffff;
        --header: #f0f0f0;
        --border: #e0e0e0;
        --muted: #757575;
      }
    }
  </style>
</head>
<body>
  <!-- ========== PERFORMANCE WARNING ========== -->
  <div id="performanceWarning" class="performance-warning">
    ‚ö†Ô∏è Wykryto wiele otwartych kart - mo≈ºe to obciƒÖ≈ºyƒá sieƒá. Zalecamy u≈ºywanie tylko jednej karty.
  </div>

  <!-- ========== VISIBILITY STATUS ========== -->
  <div id="visibilityStatus" class="visibility-status">
    ‚è∏Ô∏è Polling wstrzymany (karta nieaktywna)
  </div>

  <!-- ========== RELAY CONTROL SECTION ========== -->
  <h1>üîå Sterowanie Przeka≈∫nikami</h1>
  <div class="table-container">
    <table id="relaysTable">
      <thead>
        <tr>
          <th data-label="Przeka≈∫nik">Przeka≈∫nik</th>
          <th data-label="Status">Status</th>
          <th data-label="Powiadomienia">Powiadomienia</th>
          <th data-label="Akcje">Akcje</th>
        </tr>
      </thead>
      <tbody>
        {% for relay in relay_status %}
        <tr id="relay-row-{{ relay.id }}">
          <td data-label="Przeka≈∫nik">
            <strong>Przeka≈∫nik {{ relay.id }}</strong>
          </td>
          <td data-label="Status" class="status-cell">
            {% if relay.on %}
              <span class="status-indicator on"></span>
              <span class="badge on">W≈ÇƒÖczony ‚ö°</span>
            {% else %}
              <span class="status-indicator off"></span>
              <span class="badge off">Wy≈ÇƒÖczony</span>
            {% endif %}
          </td>
          <td data-label="Powiadomienia">
            <button 
              id="notify-btn-{{ relay.id }}" 
              class="notify-btn small notify-off" 
              onclick="toggleNotify('{{ relay.id }}', this)" 
              title="ZarzƒÖdzaj powiadomieniami"
              aria-label="Prze≈ÇƒÖcz powiadomienia dla przeka≈∫nika {{ relay.id }}">
              Powiadomienia: OFF
            </button>
          </td>
          <td data-label="Akcje">
            <button 
              onclick="controlRelay('{{ relay.id }}', 'on')" 
              id="btn-on-{{ relay.id }}"
              aria-label="W≈ÇƒÖcz przeka≈∫nik {{ relay.id }}">
              ‚ñ∂Ô∏è W≈ÇƒÖcz
            </button>
            <button 
              onclick="controlRelay('{{ relay.id }}', 'off')" 
              id="btn-off-{{ relay.id }}"
              class="secondary"
              aria-label="Wy≈ÇƒÖcz przeka≈∫nik {{ relay.id }}">
              ‚èπÔ∏è Wy≈ÇƒÖcz
            </button>
            {% if relay.id in [2, 8] and quick_start_vms %}
              {% set relay_key = 'relay_' ~ relay.id %}
              {% if quick_start_vms.get(relay_key) %}
                <div style="margin-top: var(--spacing-sm);">
                  <select 
                    id="vm-select-{{ relay.id }}" 
                    style="background: var(--card); color: var(--fg); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: var(--spacing-xs) var(--spacing-sm); font-size: 12px; margin-right: var(--spacing-xs);"
                    aria-label="Wybierz VM do uruchomienia">
                    <option value="">-- Wybierz VM --</option>
                    {% for vmid, description in quick_start_vms[relay_key].items() %}
                      <option value="{{ vmid }}">{{ description }}</option>
                    {% endfor %}
                  </select>
                  <button 
                    onclick="quickStartVM({{ relay.id }}, this)" 
                    id="btn-quick-start-{{ relay.id }}"
                    class="small"
                    style="background: var(--accent); color: #000000;"
                    aria-label="Szybki start VM dla przeka≈∫nika {{ relay.id }}">
                    üöÄ Szybki Start
                  </button>
                  <button 
                    onclick="quickShutdownVM({{ relay.id }}, this)" 
                    id="btn-quick-shutdown-{{ relay.id }}"
                    class="small secondary"
                    style="background: var(--error); color: #ffffff;"
                    aria-label="Szybkie wy≈ÇƒÖczenie dla przeka≈∫nika {{ relay.id }}">
                    üõë Szybkie Wy≈ÇƒÖczenie
                  </button>
                </div>
              {% endif %}
            {% endif %}
          </td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <div class="center">
    <button onclick="controlAllRelays('allon')" class="large">
      üöÄ W≈ÇƒÖcz Wszystkie
    </button>
    <button onclick="controlAllRelays('alloff')" class="large secondary">
      üõë Wy≈ÇƒÖcz Wszystkie
    </button>
  </div>

  <!-- ========== UNIFIED HOST MANAGEMENT SECTION ========== -->
  <h1>üíª ZarzƒÖdzanie Hostami</h1>
  <div class="table-container">
    <table id="hostsTable">
      <thead>
        <tr>
          <th data-label="Host">Host</th>
          <th data-label="Adres IP">Adres IP</th>
          <th data-label="MAC">MAC</th>
          <th data-label="Status">Status</th>
          <th data-label="Akcje">Akcje</th>
        </tr>
      </thead>
      <tbody id="hostsBody">
        <tr>
          <td colspan="5" class="loading">≈Åadowanie host√≥w...</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- ========== PROXMOX VM MANAGEMENT SECTION ========== -->
  <h1>üñ•Ô∏è VMs Proxmox</h1>
  <div class="table-container">
    <table id="vmsTable">
      <thead>
        <tr>
          <th data-label="Wƒôze≈Ç">Wƒôze≈Ç</th>
          <th data-label="Typ">Typ</th>
          <th data-label="VMID">VMID</th>
          <th data-label="Nazwa">Nazwa</th>
          <th data-label="Status">Status</th>
          <th data-label="Uptime">Uptime</th>
          <th data-label="Adresy IP">Adresy IP</th>
          <th data-label="Akcje">Akcje</th>
        </tr>
      </thead>
      <tbody id="vmsBody">
        <tr>
          <td colspan="8" class="loading">≈Åadowanie maszyn wirtualnych...</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- ========== SYSTEMD SERVICES MANAGEMENT SECTION ========== -->
  <h1>‚öôÔ∏è ZarzƒÖdzanie Us≈Çugami Systemd</h1>
  <div class="table-container">
    <table id="servicesTable">
      <thead>
        <tr>
          <th data-label="Us≈Çuga">Us≈Çuga</th>
          <th data-label="Nazwa systemd">Nazwa systemd</th>
          <th data-label="Status">Status</th>
          <th data-label="Akcje">Akcje</th>
        </tr>
      </thead>
      <tbody id="servicesBody">
        <tr>
          <td colspan="4" class="loading">≈Åadowanie us≈Çug...</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- ========== DOCKER CONTAINERS MANAGEMENT SECTION ========== -->
  <h1>üê≥ ZarzƒÖdzanie Kontenerami Docker</h1>
  <div class="table-container">
    <table id="dockerTable">
      <thead>
        <tr>
          <th data-label="Kontener">Kontener</th>
          <th data-label="Obraz">Obraz</th>
          <th data-label="Status">Status</th>
          <th data-label="Porty">Porty</th>
          <th data-label="Akcje">Akcje</th>
        </tr>
      </thead>
      <tbody id="dockerBody">
        <tr>
          <td colspan="5" class="loading">≈Åadowanie kontener√≥w...</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- ========== APPLICATION LOGS SECTION ========== -->
  <h1>üìã Logi Programu</h1>
  <div class="table-container">
    <div style="padding: var(--spacing-lg);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-md); flex-wrap: wrap; gap: var(--spacing-sm);">
        <h2 style="color: var(--purple); font-size: 16px; margin: 0;">Logi Aplikacji PowerControl</h2>
        <div style="display: flex; gap: var(--spacing-sm); align-items: center; flex-wrap: wrap;">
          <label style="display: flex; align-items: center; gap: var(--spacing-xs); font-size: 12px;">
            <span>Linie:</span>
            <select id="logsLinesSelect" onchange="LogsController.updateSettings()" style="background: var(--card); color: var(--fg); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 4px 8px; font-size: 12px;">
              <option value="50">50</option>
              <option value="100" selected>100</option>
              <option value="200">200</option>
              <option value="500">500</option>
            </select>
          </label>
          <label style="display: flex; align-items: center; gap: var(--spacing-xs); font-size: 12px;">
            <span>Poziom:</span>
            <select id="logsLevelSelect" onchange="LogsController.updateSettings()" style="background: var(--card); color: var(--fg); border: 1px solid var(--border); border-radius: var(--radius-sm); padding: 4px 8px; font-size: 12px;">
              <option value="">Wszystkie</option>
              <option value="DEBUG">DEBUG</option>
              <option value="INFO">INFO</option>
              <option value="WARNING">WARNING</option>
              <option value="ERROR">ERROR</option>
              <option value="CRITICAL">CRITICAL</option>
            </select>
          </label>
          <button 
            onclick="LogsController.toggleAutoRefresh()" 
            id="logsAutoRefreshBtn"
            class="small secondary"
            style="font-size: 11px; padding: 4px 8px;">
            ‚è∏Ô∏è Auto-od≈õwie≈ºanie: OFF
          </button>
          <button 
            onclick="LogsController.refresh()" 
            class="small"
            style="font-size: 11px; padding: 4px 8px;">
            üîÑ Od≈õwie≈º
          </button>
          <button 
            onclick="LogsController.clearDisplay()" 
            class="small secondary"
            style="font-size: 11px; padding: 4px 8px;">
            üóëÔ∏è Wyczy≈õƒá
          </button>
        </div>
      </div>
      
      <div id="logsInfo" style="font-size: 11px; color: var(--muted); margin-bottom: var(--spacing-sm);">
        ≈Åadowanie log√≥w...
      </div>
      
      <div 
        id="logsDisplay" 
        style="
          background: var(--card); 
          border: 1px solid var(--border); 
          border-radius: var(--radius-md); 
          padding: var(--spacing-md); 
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          font-size: 11px;
          color: var(--fg);
          max-height: 600px;
          overflow-y: auto;
          overflow-x: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
          line-height: 1.4;
        ">
        ≈Åadowanie log√≥w...
      </div>
    </div>
  </div>

  <!-- ========== MANUAL SECTION ========== -->
  <div class="manual-section">
    <h1>üìã Konfiguracja Przeka≈∫nik√≥w (Opis)</h1>
    <textarea 
      id="userMessage" 
      name="manual" 
      rows="8" 
      readonly
      title="Konfiguracja mapowania przeka≈∫nik√≥w (opsi)">Przeka≈∫nik 1 - SW05 (Video)
Przeka≈∫nik 2 - SW02(Prox01)
Przeka≈∫nik 3 - SW06(PwrDeck)
Przeka≈∫nik 4 - SW01(Laptops)
Przeka≈∫nik 5 - auto(Switch)
Przeka≈∫nik 6 - SW04(PC)
Przeka≈∫nik 7 - ----()
Przeka≈∫nik 8 - SW03(Prox02)</textarea>
  </div>

  <!-- ========== TOAST NOTIFICATION ========== -->
  <div id="toast" role="alert" aria-live="polite"></div>

  <!-- ========== JAVASCRIPT ========== -->
  <script>
    'use strict';

    // ========== PROXY ERROR SUPPRESSION ==========
    // Mechanizm t≈Çumienia powtarzajƒÖcych siƒô b≈Çƒôd√≥w proxy
    (function() {
      const suppressedErrors = new Set();
      const originalConsoleError = console.error;
      const originalConsoleWarn = console.warn;
      
      // T≈Çumienie powtarzajƒÖcych siƒô b≈Çƒôd√≥w proxy
      function shouldSuppressError(message, lineno) {
        if (lineno === 2 && lineno <= 10) {
          const errorKey = `${message}:${lineno}`;
          if (suppressedErrors.has(errorKey)) {
            return true;
          }
          if (message && (message.includes("expected expression") || message.includes("got '}'"))) {
            suppressedErrors.add(errorKey);
            return false; // Pierwsze wystƒÖpienie - pozw√≥l zalogowaƒá, ale zapisz
          }
        }
        return false;
      }
      
      // Nadpisz console.error aby t≈Çumiƒá powtarzajƒÖce siƒô b≈Çƒôdy proxy
      console.error = function(...args) {
        const message = args.join(' ');
        // Sprawd≈∫ czy to b≈ÇƒÖd proxy kt√≥ry ju≈º obs≈Çu≈ºyli≈õmy
        if (message.includes("expected expression") || message.includes("got '}'")) {
          // Sprawd≈∫ stack trace aby znale≈∫ƒá numer linii
          const stack = new Error().stack;
          if (stack && (stack.includes(':2:') || stack.includes(':2:1'))) {
            const errorKey = `proxy-error:${message}`;
            if (suppressedErrors.has(errorKey)) {
              return; // T≈Çum powtarzajƒÖce siƒô b≈Çƒôdy
            }
            suppressedErrors.add(errorKey);
            // Ca≈Çkowicie wycisz b≈Çƒôdy proxy - nie loguj nic
            return;
          }
        }
        originalConsoleError.apply(console, args);
      };
      
      // Nadpisz console.warn aby t≈Çumiƒá powtarzajƒÖce siƒô ostrze≈ºenia proxy
      console.warn = function(...args) {
        const message = args.join(' ');
          if (message.includes("Proxy-related syntax error") || message.includes("Proxy-related error") || 
            message.includes("expected expression") || message.includes("got '}'")) {
          const errorKey = `proxy-warn:${message}`;
          if (suppressedErrors.has(errorKey)) {
            return; // Ca≈Çkowicie t≈Çum powtarzajƒÖce siƒô ostrze≈ºenia - nie loguj nic
          }
          suppressedErrors.add(errorKey);
          // Ca≈Çkowicie wycisz - nie loguj nawet pierwszego wystƒÖpienia
          return;
        }
        originalConsoleWarn.apply(console, args);
      };
    })();

    // ========== CONFIGURATION ========== (OPTIMIZED FOR PERFORMANCE)
    const CONFIG = {
      POLL_INTERVAL_RELAYS: 3000,          // 2s ‚Üí 5s (zmniejszenie obciƒÖ≈ºenia)
      POLL_INTERVAL_NOTIFICATIONS: 10000,  // 5s ‚Üí 30s (notifications rzadziej)
      POLL_INTERVAL_VMS: 7000,            // 5s ‚Üí 10s (VM status rzadziej) 
      POLL_INTERVAL_HOSTS: 60000,          // 30s ‚Üí 60s (lista host√≥w rzadziej)
      PING_INTERVAL_HOSTS: 300000,         // 60s ‚Üí 300s (5 minut - ZNACZNE ZMNIEJSZENIE!)
      TOAST_DURATION: 3000,
      VM_REFRESH_DELAY: 1200,
      
      // Tab visibility intervals (gdy karta aktywna)
      ACTIVE_MULTIPLIER: 1,
      // Tab visibility intervals (gdy karta nieaktywna - dramatycznie rzadziej)
      INACTIVE_MULTIPLIER: 5,  // 5x rzadziej gdy nieaktywna
      
      // Intelligent VM refresh configuration
      VM_REFRESH_BASE: 7000,              // Bazowy interwa≈Ç (7s)
      VM_REFRESH_STABLE: 15000,           // Gdy brak zmian (15s)
      VM_REFRESH_QUIET: 30000,            // Gdy d≈Çugo brak zmian (30s)
      VM_REFRESH_IDLE: 60000,             // Gdy bardzo d≈Çugo brak zmian (60s)
      VM_REFRESH_MAX: 60000,              // Maksymalny interwa≈Ç (60s)
      VM_CHANGE_DETECTION_CYCLES: 3,      // Liczba cykli bez zmian przed zwiƒôkszeniem interwa≈Çu
      VM_RUNNING_PRIORITY_MULTIPLIER: 0.7 // Running VM od≈õwie≈ºane czƒô≈õciej (70% interwa≈Çu)
    };

    // ========== TAB VISIBILITY DETECTION ==========
    const VisibilityManager = {
      isVisible: true,
      intervalIds: {},
      sseActive: false,
      
      init() {
        document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
        
        // Performance Storage API dla wykrywania wielu kart
        this.detectMultipleTabs();
        
        this.isVisible = !document.hidden;
        this.updateVisibilityUI();
      },
      
      handleVisibilityChange() {
        if (this.sseActive) {
          // przy SSE nie zmieniamy interwa≈Ç√≥w, ale informujemy UI
          this.isVisible = !document.hidden;
          this.updateVisibilityUI();
          return;
        }
        const wasVisible = this.isVisible;
        this.isVisible = !document.hidden;
        
        if (this.isVisible !== wasVisible) {
          console.log(`Tab visibility changed: ${this.isVisible ? 'visible' : 'hidden'}`);
          
          if (this.isVisible) {
            this.resumePolling();
            Utils.showToast('‚ñ∂Ô∏è Polling wznowiony - karta aktywna');
          } else {
            this.pausePolling();
            Utils.showToast('‚è∏Ô∏è Polling wstrzymany - oszczƒôdzanie zasob√≥w');
          }
          
          this.updateVisibilityUI();
        }
      },
      
      pausePolling() {
        if (this.sseActive) return;
        // Zatrzymaj wszystkie timery
        Object.values(this.intervalIds).forEach(id => {
          if (id) clearInterval(id);
        });
        
        // Zatrzymaj adaptacyjne od≈õwie≈ºanie VM
        VMController.stopAdaptiveRefresh();
        
        // Ustaw znacznie rzadsze interwa≈Çy dla kart w tle
        this.intervalIds.relayPoll = setInterval(
          RelayController.pollStatus, 
          CONFIG.POLL_INTERVAL_RELAYS * CONFIG.INACTIVE_MULTIPLIER
        );
        
        this.intervalIds.hostsList = setInterval(
          HostController.load.bind(HostController), 
          CONFIG.POLL_INTERVAL_HOSTS * CONFIG.INACTIVE_MULTIPLIER
        );
        
        // Wy≈ÇƒÖcz zupe≈Çnie ping i VM polling dla nieaktywnych kart
        // (ping bƒôdzie dzia≈Çaƒá tylko z aktywnych kart)
      },
      
      resumePolling() {
        if (this.sseActive) return;
        // Zatrzymaj stare timery
        Object.values(this.intervalIds).forEach(id => {
          if (id) clearInterval(id);
        });
        
        // Przywr√≥ƒá normalne interwa≈Çy
        this.intervalIds.relayPoll = setInterval(RelayController.pollStatus, CONFIG.POLL_INTERVAL_RELAYS);
        this.intervalIds.notificationsFetch = setInterval(NotificationController.fetchStates, CONFIG.POLL_INTERVAL_NOTIFICATIONS);
        this.intervalIds.hostsList = setInterval(HostController.load.bind(HostController), CONFIG.POLL_INTERVAL_HOSTS);
        this.intervalIds.hostsAutoPing = setInterval(HostController.autoPingAll.bind(HostController), CONFIG.PING_INTERVAL_HOSTS);
        
        // Uruchom adaptacyjne od≈õwie≈ºanie VM zamiast sta≈Çego interwa≈Çu
        VMController.startAdaptiveRefresh();
      },
      
      stopPolling() {
        Object.values(this.intervalIds).forEach(id => {
          if (id) clearInterval(id);
        });
        this.intervalIds = {};
      },
      
      setSSEActive(active) {
        this.sseActive = active;
        if (active) {
          this.stopPolling();
          VMController.stopAdaptiveRefresh();
        } else if (this.isVisible) {
          this.resumePolling();
        } else {
          this.pausePolling();
        }
      },
      
      updateVisibilityUI() {
        const statusEl = document.getElementById('visibilityStatus');
        if (statusEl) {
          statusEl.className = this.isVisible ? 'visibility-status' : 'visibility-status paused';
        }
      },
      
      detectMultipleTabs() {
        // U≈ºyj localStorage do wykrycia wielu otwartych kart
        try {
          const tabId = Date.now() + '-' + Math.random();
          const tabsKey = 'powercontrol-active-tabs';
          
          // Rejestruj tƒô kartƒô
          const existingTabs = JSON.parse(localStorage.getItem(tabsKey) || '[]');
          const activeTabs = [...existingTabs, tabId];
          localStorage.setItem(tabsKey, JSON.stringify(activeTabs));
          
          // Sprawd≈∫ co 5 sekund czy sƒÖ inne aktywne karty
          setInterval(() => {
            try {
              const current = JSON.parse(localStorage.getItem(tabsKey) || '[]');
              const warningEl = document.getElementById('performanceWarning');
              
              if (current.length > 1) {
                warningEl?.classList.add('show');
              } else {
                warningEl?.classList.remove('show');
              }
            } catch (e) {
              console.debug('Multiple tabs detection error:', e);
            }
          }, 5000);
          
          // Cleanup przy zamkniƒôciu
          window.addEventListener('beforeunload', () => {
            try {
              const current = JSON.parse(localStorage.getItem(tabsKey) || '[]');
              const filtered = current.filter(id => id !== tabId);
              localStorage.setItem(tabsKey, JSON.stringify(filtered));
            } catch (e) {
              console.debug('Tab cleanup error:', e);
            }
          });
          
        } catch (e) {
          console.debug('Multiple tabs detection not available:', e);
        }
      }
    };

    // ========== SSE (Server-Sent Events) ==========
    const SSEController = {
      es: null,
      connected: false,
      retryTimer: null,
      init() {
        if (!window.EventSource) {
          console.warn('EventSource not supported, staying on polling');
          return;
        }
        this.connect();
      },
      connect() {
        if (this.es) {
          try { this.es.close(); } catch (e) {}
        }
        this.es = new EventSource('/events');
        this.es.onopen = () => {
          this.connected = true;
          console.log('SSE connected');
          VisibilityManager.setSSEActive(true);
          Utils.showToast('üîå Po≈ÇƒÖczono SSE (live)');
        };
        this.es.onerror = () => {
          console.warn('SSE error, falling back to polling');
          this.connected = false;
          VisibilityManager.setSSEActive(false);
          try { this.es.close(); } catch (e) {}
          clearTimeout(this.retryTimer);
          this.retryTimer = setTimeout(() => this.connect(), 5000);
        };
        this.es.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data || '{}');
            this.handle(data);
          } catch (e) {
            console.debug('SSE parse error', e);
          }
        };
      },
      handle(payload) {
        if (!payload || !payload.type) return;
        switch (payload.type) {
          case 'relays':
            RelayController.applySnapshot(payload.relays || []);
            break;
          case 'hosts':
            HostController.renderSnapshot(payload.hosts || []);
            break;
          case 'vms':
            // Dla SSE, r√≥wnie≈º aktualizuj snapshot i resetuj interwa≈Ç
            const vms = payload.vms || [];
            const hasChanges = VMController.detectChanges(vms);
            if (hasChanges) {
              VMController.noChangeCycles = 0;
              VMController.currentInterval = CONFIG.VM_REFRESH_BASE;
            }
            // Zawsze renderuj dla SSE (dane przychodzƒÖ z serwera)
            VMController.renderSnapshot(vms);
            break;
          default:
            break;
        }
      }
    };

    // ========== UTILITIES ==========
    const Utils = {
      escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },
      
      showToast(message) {
        const toast = document.getElementById('toast');
        if (!toast) return;
        
        toast.textContent = message;
        toast.classList.add('show');
        
        clearTimeout(Utils.showToast._timer);
        Utils.showToast._timer = setTimeout(() => {
          toast.classList.remove('show');
        }, CONFIG.TOAST_DURATION);
      },

      formatUptime(seconds) {
        if (!seconds || seconds <= 0) return '‚Äî';
        
        let sec = Math.floor(seconds);
        const days = Math.floor(sec / 86400);
        sec %= 86400;
        const hours = Math.floor(sec / 3600);
        sec %= 3600;
        const minutes = Math.floor(sec / 60);
        
        const parts = [];
        if (days) parts.push(`${days}d`);
        if (hours) parts.push(`${hours}h`);
        if (minutes) parts.push(`${minutes}m`);
        
        return parts.join(' ') || '0m';
      },

      async copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          Utils.showToast(`Skopiowano: ${text}`);
        } catch (error) {
          console.warn('Clipboard copy failed:', error);
          Utils.showToast('Nie uda≈Ço siƒô skopiowaƒá do schowka');
        }
      },

      async fetchJSON(url, options = {}) {
        try {
          const response = await fetch(url, {
            headers: {
              'Content-Type': 'application/json',
              ...options.headers
            },
            ...options
          });
          
          // Sprawd≈∫ czy response ma content-type JSON
          const contentType = response.headers.get('content-type');
          const isJson = contentType && contentType.includes('application/json');
          
          if (!response.ok) {
            let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
            // Spr√≥buj wyciƒÖgnƒÖƒá szczeg√≥≈Çy b≈Çƒôdu z JSON je≈õli dostƒôpne
            if (isJson) {
              try {
                const errorData = await response.json();
                errorMessage = errorData.error || errorData.message || errorMessage;
              } catch (e) {
                // Nie mo≈ºna sparsowaƒá JSON, u≈ºyj domy≈õlnego komunikatu
              }
            }
            const error = new Error(errorMessage);
            error.status = response.status;
            error.response = response;
            throw error;
          }
          
          if (isJson) {
            return await response.json();
          } else {
            // Je≈õli nie ma JSON, zwr√≥ƒá pusty obiekt
            const text = await response.text();
            return { success: true, data: text };
          }
        } catch (error) {
          // Oznacz b≈ÇƒÖd jako obs≈Çu≈ºony je≈õli to jest b≈ÇƒÖd sieciowy
          if (error.name === 'TypeError' && error.message.includes('fetch')) {
            error._handled = true;
          }
          throw error;
        }
      },

      debounce(func, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
      },

      setElementsDisabled(elements, disabled) {
        elements.forEach(el => {
          if (el) el.disabled = disabled;
        });
      }
    };

    // ========== RELAY MANAGEMENT ==========
    const RelayController = {
      applySnapshot(relays) {
        if (!Array.isArray(relays)) return;
        relays.forEach(relay => {
          if (!relay) return;
          RelayController.updateUI(relay.id, !!relay.on);
        });
      },
      updateUI(relayId, isOn) {
        const row = document.getElementById(`relay-row-${relayId}`);
        if (!row) return;

        const statusCell = row.querySelector('.status-cell');
        if (statusCell) {
          const indicator = isOn 
            ? '<span class="status-indicator on"></span><span class="badge on">W≈ÇƒÖczony ‚ö°</span>'
            : '<span class="status-indicator off"></span><span class="badge off">Wy≈ÇƒÖczony</span>';
          statusCell.innerHTML = indicator;
        }

        // Update button states
        const btnOn = document.getElementById(`btn-on-${relayId}`);
        const btnOff = document.getElementById(`btn-off-${relayId}`);
        
        if (btnOn) btnOn.disabled = isOn;
        if (btnOff) btnOff.disabled = !isOn;
      },

      async pollStatus() {
        try {
          const data = await Utils.fetchJSON('/debug/relays');
          if (data?.success && Array.isArray(data.relays)) {
            data.relays.forEach(relay => {
              RelayController.updateUI(relay.id, !!relay.on);
            });
          }
        } catch (error) {
          console.debug('Relay polling failed:', error);
        }
      },

      async control(relayId, action) {
        const btnOn = document.getElementById(`btn-on-${relayId}`);
        const btnOff = document.getElementById(`btn-off-${relayId}`);
        
        Utils.setElementsDisabled([btnOn, btnOff], true);
        
        try {
          const data = await Utils.fetchJSON(`/relay/${relayId}/${action}`, {
            method: 'POST'
          });
          
          if (data?.success) {
            Utils.showToast(`Przeka≈∫nik ${relayId}: ${action === 'on' ? 'w≈ÇƒÖczony' : 'wy≈ÇƒÖczony'}`);
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Relay control error:', error);
          alert(`B≈ÇƒÖd sterowania przeka≈∫nikiem: ${error.message}`);
        } finally {
          Utils.setElementsDisabled([btnOn, btnOff], false);
        }
      },

      async controlAll(action) {
        try {
          const data = await Utils.fetchJSON(`/${action}`, { method: 'POST' });
          
          if (data?.success) {
            const actionText = action === 'allon' ? 'w≈ÇƒÖczenie' : 'wy≈ÇƒÖczenie';
            Utils.showToast(`Wys≈Çano polecenie: ${actionText} wszystkich przeka≈∫nik√≥w`);
            setTimeout(RelayController.pollStatus, 200);
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Relay control all error:', error);
          alert(`B≈ÇƒÖd sterowania wszystkimi przeka≈∫nikami: ${error.message}`);
        }
      }
    };

    // ========== QUICK START VM ==========
    const QuickStartVM = {
      // Zapisz ostatni wyb√≥r VM dla przeka≈∫nika (wsp√≥≈Çdzielony miƒôdzy urzƒÖdzeniami)
      async saveLastChoice(relayId, vmid) {
        try {
          await Utils.fetchJSON('/quick_start/choice', {
            method: 'POST',
            body: JSON.stringify({
              relay_id: relayId,
              vmid: vmid
            })
          });
        } catch (e) {
          console.debug('Failed to save quick start choice:', e);
        }
      },
      
      // Przywr√≥ƒá ostatni wyb√≥r VM dla przeka≈∫nika (wsp√≥≈Çdzielony miƒôdzy urzƒÖdzeniami)
      async restoreLastChoice(relayId) {
        try {
          const data = await Utils.fetchJSON('/quick_start/choice');
          if (data?.success && data.choices) {
            const saved = data.choices[String(relayId)];
            if (saved) {
              const select = document.getElementById(`vm-select-${relayId}`);
              if (select) {
                // Sprawd≈∫ czy zapisana warto≈õƒá istnieje w opcjach
                const optionExists = Array.from(select.options).some(opt => opt.value === String(saved));
                if (optionExists) {
                  select.value = String(saved);
                }
              }
            }
          }
        } catch (e) {
          console.debug('Failed to restore quick start choice:', e);
        }
      },
      
      // Przywr√≥ƒá wybory dla wszystkich przeka≈∫nik√≥w
      async restoreAllChoices() {
        await Promise.all([
          this.restoreLastChoice(2),
          this.restoreLastChoice(8)
        ]);
      }
    };
    
    async function quickStartVM(relayId, button) {
      const select = document.getElementById(`vm-select-${relayId}`);
      if (!select) {
        alert('B≈ÇƒÖd: Nie znaleziono listy wyboru VM');
        return;
      }
      
      const vmid = select.value;
      if (!vmid) {
        alert('Proszƒô wybraƒá VM z listy');
        return;
      }
      
      // Zapisz wyb√≥r do backendu (wsp√≥≈Çdzielony miƒôdzy urzƒÖdzeniami)
      await QuickStartVM.saveLastChoice(relayId, vmid);
      
      const originalText = button.textContent;
      button.disabled = true;
      button.textContent = '‚è≥ Czekam...';
      select.disabled = true;
      
      try {
        Utils.showToast(`üöÄ Uruchamianie szybkiego startu: Przeka≈∫nik ${relayId} ‚Üí VM ${vmid}`);
        
        const data = await Utils.fetchJSON(`/relay/${relayId}/quick_start`, {
          method: 'POST',
          body: JSON.stringify({
            vmid: parseInt(vmid),
            type: 'qemu'  // Node jest automatycznie wykrywany na podstawie relay ID
          })
        });
        
        if (data?.success) {
          const taskid = data.taskid ? ` (task: ${data.taskid})` : '';
          Utils.showToast(`‚úÖ Szybki start zako≈Ñczony: Przeka≈∫nik ${relayId} w≈ÇƒÖczony, Proxmox gotowy, VM ${vmid} uruchomiony${taskid}`);
          
          // Od≈õwie≈º status przeka≈∫nik√≥w i VM po kr√≥tkiej chwili
          setTimeout(() => {
            RelayController.pollStatus();
            if (typeof VMController !== 'undefined' && VMController.load) {
              VMController.load();
            }
          }, 2000);
        } else {
          throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
        }
      } catch (error) {
        console.error('Quick start error:', error);
        alert(`B≈ÇƒÖd szybkiego startu: ${error.message}`);
      } finally {
        button.disabled = false;
        button.textContent = originalText;
        select.disabled = false;
      }
    }
    
    // ========== QUICK SHUTDOWN VM ==========
    async function quickShutdownVM(relayId, button) {
      if (!confirm(`‚ö†Ô∏è Czy na pewno chcesz wykonaƒá szybkie wy≈ÇƒÖczenie dla przeka≈∫nika ${relayId}?\n\nTo spowoduje:\n1. Wy≈ÇƒÖczenie wszystkich uruchomionych VM\n2. Wy≈ÇƒÖczenie Proxmox node\n3. Wy≈ÇƒÖczenie przeka≈∫nika po 5 minutach\n\nOperacja jest nieodwracalna!`)) {
        return;
      }
      
      const originalText = button.textContent;
      button.disabled = true;
      button.textContent = '‚è≥ Wy≈ÇƒÖczanie...';
      
      try {
        Utils.showToast(`üõë Rozpoczynam szybkie wy≈ÇƒÖczenie: Przeka≈∫nik ${relayId}`);
        
        const data = await Utils.fetchJSON(`/relay/${relayId}/quick_shutdown`, {
          method: 'POST'
        });
        
        if (data?.success) {
          const vmsCount = data.vms_shutdown || 0;
          const waitTime = data.relay_will_off_in_seconds || 300;
          const waitMinutes = Math.floor(waitTime / 60);
          
          Utils.showToast(`‚úÖ Sekwencja wy≈ÇƒÖczenia rozpoczƒôta: ${vmsCount} VM wy≈ÇƒÖczonych, node wy≈ÇƒÖczony, przeka≈∫nik ${relayId} wy≈ÇƒÖczy siƒô za ${waitMinutes} minut`);
          
          // Od≈õwie≈º status przeka≈∫nik√≥w i VM po kr√≥tkiej chwili
          setTimeout(() => {
            RelayController.pollStatus();
            if (typeof VMController !== 'undefined' && VMController.load) {
              VMController.load();
            }
          }, 2000);
          
          // Poka≈º dodatkowe informacje
          if (data.vm_results && data.vm_results.length > 0) {
            const failed = data.vm_results.filter(r => !r.success);
            if (failed.length > 0) {
              console.warn('Some VMs failed to shutdown:', failed);
            }
          }
        } else {
          throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
        }
      } catch (error) {
        console.error('Quick shutdown error:', error);
        alert(`B≈ÇƒÖd szybkiego wy≈ÇƒÖczenia: ${error.message}`);
      } finally {
        button.disabled = false;
        button.textContent = originalText;
      }
    }

    // ========== NOTIFICATION MANAGEMENT ==========
    const NotificationController = {
      applyButtonState(button, enabled) {
        if (!button) return;
        
        if (enabled) {
          button.classList.remove('notify-off');
          button.classList.add('notify-on');
          button.textContent = 'Powiadomienia: ON';
          button.title = 'Powiadomienia w≈ÇƒÖczone. Kliknij aby wy≈ÇƒÖczyƒá.';
        } else {
          button.classList.remove('notify-on');
          button.classList.add('notify-off');
          button.textContent = 'Powiadomienia: OFF';
          button.title = 'Powiadomienia wy≈ÇƒÖczone. Kliknij aby w≈ÇƒÖczyƒá.';
        }
        button.disabled = false;
      },

      async fetchStates() {
        try {
          const data = await Utils.fetchJSON('/debug/relay_notifications');
          if (data?.success && data.notifications) {
            Object.entries(data.notifications).forEach(([relayId, enabled]) => {
              const button = document.getElementById(`notify-btn-${relayId}`);
              NotificationController.applyButtonState(button, !!enabled);
            });
          }
        } catch (error) {
          console.debug('Notification states fetch failed:', error);
        }
      },

      async toggle(relayId, button) {
        button.disabled = true;
        const currentlyEnabled = button.classList.contains('notify-on');
        const newState = !currentlyEnabled;
        
        try {
          const data = await Utils.fetchJSON(`/relay/${relayId}/notify`, {
            method: 'POST',
            body: JSON.stringify({ enabled: newState })
          });
          
          if (data?.success) {
            NotificationController.applyButtonState(button, !!data.enabled);
            const stateText = data.enabled ? 'w≈ÇƒÖczone' : 'wy≈ÇƒÖczone';
            Utils.showToast(`Powiadomienia dla przeka≈∫nika ${relayId}: ${stateText}`);
          } else {
            throw new Error(data?.error || data?.message || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Notification toggle error:', error);
          alert(`B≈ÇƒÖd zmiany powiadomie≈Ñ: ${error.message}`);
          NotificationController.applyButtonState(button, currentlyEnabled);
        }
      }
    };

    // ========== UNIFIED HOST MANAGEMENT ==========
    const HostController = {
      hosts: new Map(),
      pingStates: new Map(),

      renderSnapshot(hosts = []) {
        const tbody = document.getElementById('hostsBody');
        if (!tbody) return;

        if (!hosts.length) {
          tbody.innerHTML = '<tr><td colspan="5">üì≠ Brak skonfigurowanych host√≥w</td></tr>';
          return;
        }

        tbody.innerHTML = '';
        hosts.forEach(host => {
          const row = document.createElement('tr');
          const hostId = host.hostname || host.name;
          const status = host.status || 'unknown';
          const pingStatus = this.pingStates.get(hostId) || status || 'unknown';

          row.innerHTML = `
            <td data-label="Host"><strong>${hostId}</strong></td>
            <td data-label="Adres IP"><code>${host.ip || ''}</code></td>
            <td data-label="MAC"><code>${host.mac || '‚Äî'}</code></td>
            <td data-label="Status" class="status-cell">
              ${this.renderStatusBadge(status)}
              ${this.renderPingButton(hostId, pingStatus)}
            </td>
            <td data-label="Akcje">
              <button onclick="HostController.wake('${hostId}')" title="Wake on LAN">
                üåÖ WOL
              </button>
              <button onclick="HostController.shutdown('${hostId}')" class="secondary" title="Shutdown via SSH">
                üõë Shutdown
              </button>
              <button onclick="HostController.reboot('${hostId}')" class="secondary" title="Restart via SSH">
                üîÑ Restart
              </button>
            </td>
          `;
          tbody.appendChild(row);
          this.hosts.set(hostId, host);

          // zapamiƒôtaj status do kolorowania przycisku ping
          const pingState = status === 'online' ? 'online' : status === 'offline' ? 'offline' : 'unknown';
          this.pingStates.set(hostId, pingState);
        });
      },

      renderStatusBadge(status) {
        const statusClass = status === 'online' ? 'online' : 
                           status === 'offline' ? 'offline' : 'unknown';
        const statusText = status === 'online' ? 'Online' : 
                          status === 'offline' ? 'Offline' : 'Nieznany';
        return `
          <span class="status-indicator ${statusClass}"></span>
          <span class="badge ${statusClass}">${statusText}</span>
        `;
      },

      renderPingButton(hostId, status) {
        const btnClass = status === 'pinging' ? 'pinging' :
                        status === 'online' ? 'online' :
                        status === 'offline' ? 'offline' : '';
        const btnText = status === 'pinging' ? '‚è≥' :
                       status === 'online' ? '‚úÖ' :
                       status === 'offline' ? '‚ùå' : '‚ùì';
        
        return `<button class="ping-btn ${btnClass}" onclick="HostController.ping('${hostId}', this)" title="Ping host (ostatni auto-ping: 5min)">${btnText}</button>`;
      },

      async load() {
        const tbody = document.getElementById('hostsBody');
        if (!tbody) return;
        
        try {
          const data = await Utils.fetchJSON('/hosts/list');
          
          if (!data.success) {
            tbody.innerHTML = `<tr><td colspan="5">‚ùå B≈ÇƒÖd: ${data.error || 'brak szczeg√≥≈Ç√≥w'}</td></tr>`;
            return;
          }
          
          const hosts = data.hosts || [];
          
          if (!hosts.length) {
            tbody.innerHTML = '<tr><td colspan="5">üì≠ Brak skonfigurowanych host√≥w</td></tr>';
            return;
          }
          
          this.renderSnapshot(hosts);
        } catch (error) {
          console.error('Host loading error:', error);
          tbody.innerHTML = '<tr><td colspan="5">‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z serwerem</td></tr>';
        }
      },

      async wake(hostId) {
        try {
          const data = await Utils.fetchJSON(`/hosts/${hostId}/wake`, {
            method: 'POST'
          });
          
          if (data?.success) {
            Utils.showToast(`üåÖ Wys≈Çano magiczny pakiet WOL do ${hostId}`);
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Host wake error:', error);
          alert(`B≈ÇƒÖd uruchamiania hosta: ${error.message}`);
        }
      },

      async shutdown(hostId) {
        if (!confirm(`‚ùì Czy na pewno wy≈ÇƒÖczyƒá host ${hostId}?`)) return;
        
        try {
          const data = await Utils.fetchJSON(`/hosts/${hostId}/shutdown`, {
            method: 'POST'
          });
          
          if (data?.success) {
            Utils.showToast(`üõë Wys≈Çano polecenie shutdown do ${hostId}`);
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Host shutdown error:', error);
          alert(`B≈ÇƒÖd wy≈ÇƒÖczania hosta: ${error.message}`);
        }
      },

      async reboot(hostId) {
        if (!confirm(`‚ùì Czy na pewno zrestartowaƒá host ${hostId}?`)) return;
        
        try {
          const data = await Utils.fetchJSON(`/hosts/${hostId}/reboot`, {
            method: 'POST'
          });
          
          if (data?.success) {
            Utils.showToast(`üîÑ Wys≈Çano polecenie restart do ${hostId}`);
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Host reboot error:', error);
          alert(`B≈ÇƒÖd restartowania hosta: ${error.message}`);
        }
      },

      async ping(hostId, button) {
        if (!hostId || !button) return;
        
        // Update button to show pinging state
        this.pingStates.set(hostId, 'pinging');
        button.className = 'ping-btn pinging';
        button.innerHTML = '‚è≥';
        button.disabled = true;
        
        try {
          const data = await Utils.fetchJSON(`/hosts/${hostId}/ping`, {
            method: 'POST'
          });
          
          const status = data?.success && data?.reachable ? 'online' : 'offline';
          this.pingStates.set(hostId, status);
          
          // Update button appearance
          const btnClass = status === 'online' ? 'online' : 'offline';
          const btnText = status === 'online' ? '‚úÖ' : '‚ùå';
          button.className = `ping-btn ${btnClass}`;
          button.innerHTML = btnText;
          
          // Update status indicator in the same row
          const statusCell = button.closest('tr')?.querySelector('.status-cell');
          if (statusCell) {
            const badge = statusCell.querySelector('.badge');
            const indicator = statusCell.querySelector('.status-indicator');
            if (badge && indicator) {
              const statusText = status === 'online' ? 'Online' : 'Offline';
              badge.className = `badge ${status}`;
              badge.textContent = statusText;
              indicator.className = `status-indicator ${status}`;
            }
          }
          
          const statusText = status === 'online' ? 'dostƒôpny' : 'niedostƒôpny';
          Utils.showToast(`üîç ${hostId} jest ${statusText}`);
          
        } catch (error) {
          console.error('Host ping error:', error);
          this.pingStates.set(hostId, 'offline');
          button.className = 'ping-btn offline';
          button.innerHTML = '‚ùå';
          Utils.showToast(`‚ùå B≈ÇƒÖd ping ${hostId}: ${error.message}`);
        } finally {
          button.disabled = false;
        }
      },

      async autoPingAll() {
        // Tylko gdy karta jest aktywna lub wszystkie karty nieaktywne
        if (!VisibilityManager.isVisible) {
          console.debug('Skipping auto-ping - tab not visible');
          return;
        }
        
        console.debug('üîç Auto-ping wszystkich host√≥w (co 5 minut)');
        
        // Automatically ping all hosts periodically
        this.hosts.forEach(async (host, hostId) => {
          try {
            const data = await Utils.fetchJSON(`/hosts/${hostId}/ping`, {
              method: 'POST'
            });
            
            const status = data?.success && data?.reachable ? 'online' : 'offline';
            this.pingStates.set(hostId, status);
            
            // Update UI if visible
            const tbody = document.getElementById('hostsBody');
            if (tbody) {
              const rows = tbody.querySelectorAll('tr');
              rows.forEach(row => {
                const hostCell = row.querySelector('td[data-label="Host"] strong');
                if (hostCell && hostCell.textContent === hostId) {
                  const statusCell = row.querySelector('.status-cell');
                  if (statusCell) {
                    const badge = statusCell.querySelector('.badge');
                    const indicator = statusCell.querySelector('.status-indicator');
                    const pingBtn = statusCell.querySelector('.ping-btn');
                    
                    if (badge && indicator && pingBtn) {
                      const statusText = status === 'online' ? 'Online' : 'Offline';
                      const btnText = status === 'online' ? '‚úÖ' : '‚ùå';
                      
                      badge.className = `badge ${status}`;
                      badge.textContent = statusText;
                      indicator.className = `status-indicator ${status}`;
                      pingBtn.className = `ping-btn ${status}`;
                      pingBtn.innerHTML = btnText;
                    }
                  }
                }
              });
            }
          } catch (error) {
            console.debug(`Auto-ping failed for ${hostId}:`, error);
            this.pingStates.set(hostId, 'offline');
          }
        });
      }
    };

    // ========== VM MANAGEMENT ========== (INTELLIGENT REFRESH)
    const VMController = {
      vmOrder: new Map(),
      nextIndex: 0,
      lastSnapshotHash: null,         // Hash ostatniego snapshotu dla wykrywania zmian
      lastVMs: null,                   // Ostatnia lista VM dla oblicze≈Ñ interwa≈Çu
      noChangeCycles: 0,               // Licznik cykli bez zmian
      currentInterval: CONFIG.VM_REFRESH_BASE,  // Aktualny interwa≈Ç od≈õwie≈ºania
      refreshTimer: null,              // Timer dla adaptacyjnego od≈õwie≈ºania

      // Tworzy hash snapshotu dla szybkiego por√≥wnania
      createSnapshotHash(vms) {
        if (!vms || !vms.length) return '';
        // Tworzy hash z kluczowych danych: node|type|vmid|status|uptime
        return vms.map(vm => 
          `${vm.node}|${vm.type}|${vm.vmid}|${(vm.status || '').toLowerCase()}|${vm.uptime || 0}`
        ).sort().join('||');
      },

      // Wykrywa zmiany w snapshotach
      detectChanges(newVms) {
        const newHash = this.createSnapshotHash(newVms);
        const oldHash = this.lastSnapshotHash;
        
        if (oldHash === null) {
          // Pierwsze za≈Çadowanie
          this.lastSnapshotHash = newHash;
          this.lastVMs = newVms;
          return true; // Traktuj jako zmianƒô aby zresetowaƒá interwa≈Ç
        }
        
        const hasChanges = newHash !== oldHash;
        this.lastSnapshotHash = newHash;
        this.lastVMs = newVms;
        return hasChanges;
      },

      // Oblicza optymalny interwa≈Ç na podstawie stanu VM
      calculateOptimalInterval(vms) {
        if (!vms || !vms.length) {
          return CONFIG.VM_REFRESH_IDLE; // Brak VM = bardzo rzadko
        }

        // Sprawd≈∫ ile VM jest running
        const runningCount = vms.filter(vm => 
          (vm.status || '').toLowerCase() === 'running'
        ).length;
        
        const totalCount = vms.length;
        const runningRatio = totalCount > 0 ? runningCount / totalCount : 0;

        // Je≈õli wszystkie VM sƒÖ stopped, u≈ºywaj d≈Çu≈ºszych interwa≈Ç√≥w
        if (runningCount === 0) {
          // Wszystkie stopped - u≈ºyj d≈Çu≈ºszych interwa≈Ç√≥w
          if (this.noChangeCycles >= CONFIG.VM_CHANGE_DETECTION_CYCLES * 3) {
            return CONFIG.VM_REFRESH_IDLE; // 60s
          } else if (this.noChangeCycles >= CONFIG.VM_CHANGE_DETECTION_CYCLES * 2) {
            return CONFIG.VM_REFRESH_QUIET; // 30s
          } else if (this.noChangeCycles >= CONFIG.VM_CHANGE_DETECTION_CYCLES) {
            return CONFIG.VM_REFRESH_STABLE; // 15s
          }
          return CONFIG.VM_REFRESH_BASE; // 7s
        }

        // SƒÖ running VM - dostosuj interwa≈Ç
        let baseInterval = CONFIG.VM_REFRESH_BASE;
        
        // Zastosuj exponential backoff je≈õli brak zmian
        if (this.noChangeCycles >= CONFIG.VM_CHANGE_DETECTION_CYCLES * 3) {
          baseInterval = CONFIG.VM_REFRESH_IDLE;
        } else if (this.noChangeCycles >= CONFIG.VM_CHANGE_DETECTION_CYCLES * 2) {
          baseInterval = CONFIG.VM_REFRESH_QUIET;
        } else if (this.noChangeCycles >= CONFIG.VM_CHANGE_DETECTION_CYCLES) {
          baseInterval = CONFIG.VM_REFRESH_STABLE;
        }
        
        // Je≈õli sƒÖ running VM, zmniejsz interwa≈Ç (priorytet dla aktywnych)
        if (runningRatio > 0.5) {
          baseInterval = Math.floor(baseInterval * CONFIG.VM_RUNNING_PRIORITY_MULTIPLIER);
          // Upewnij siƒô, ≈ºe nie spadnie poni≈ºej minimum
          baseInterval = Math.max(CONFIG.VM_REFRESH_BASE, baseInterval);
        }

        return baseInterval;
      },

      // Uruchamia adaptacyjne od≈õwie≈ºanie
      startAdaptiveRefresh() {
        this.stopAdaptiveRefresh();
        
        const scheduleNext = () => {
          if (!VisibilityManager.isVisible) {
            return; // Nie planuj je≈õli karta nieaktywna
          }
          
          this.refreshTimer = setTimeout(() => {
            this.load().then(() => {
              // Zaplanuj nastƒôpne od≈õwie≈ºanie z nowym interwa≈Çem
              // U≈ºyj ostatniej listy VM lub danych z localStorage jako fallback
              const vmsForCalc = this.lastVMs || 
                (localStorage.getItem('vm_last_data') ? 
                  JSON.parse(localStorage.getItem('vm_last_data')) : []);
              this.currentInterval = this.calculateOptimalInterval(vmsForCalc);
              scheduleNext();
            }).catch(err => {
              console.debug('VM adaptive refresh error:', err);
              // W przypadku b≈Çƒôdu, u≈ºyj bazowego interwa≈Çu
              this.currentInterval = CONFIG.VM_REFRESH_BASE;
              scheduleNext();
            });
          }, this.currentInterval);
        };
        
        scheduleNext();
      },

      // Zatrzymuje adaptacyjne od≈õwie≈ºanie
      stopAdaptiveRefresh() {
        if (this.refreshTimer) {
          clearTimeout(this.refreshTimer);
          this.refreshTimer = null;
        }
      },

      renderSnapshot(vms = []) {
        const tbody = document.getElementById('vmsBody');
        if (!tbody) return;

        vms = this.ensureOrder(vms || []);

        if (!vms.length) {
          tbody.innerHTML = '<tr><td colspan="8">üì≠ Brak maszyn wirtualnych</td></tr>';
          return;
        }

        tbody.innerHTML = '';
        vms.forEach(vm => {
          const row = document.createElement('tr');
          const status = (vm.status || '').toLowerCase();
          const badgeClass = status === 'running' ? 'running' : 
                           (status === 'stopped' || status === 'shutdown') ? 'stopped' : 'paused';
          const ipsHtml = this.renderIPs(vm.ips || []);
          
          row.innerHTML = `
            <td data-label="Wƒôze≈Ç"><strong>${vm.node || ''}</strong></td>
            <td data-label="Typ"><code>${(vm.type || '').toUpperCase()}</code></td>
            <td data-label="VMID"><code>${vm.vmid || ''}</code></td>
            <td data-label="Nazwa">${vm.name || ''}</td>
            <td data-label="Status">
              <span class="badge ${badgeClass}">${status || '‚Äî'}</span>
            </td>
            <td data-label="Uptime">${Utils.formatUptime(vm.uptime || 0)}</td>
            <td data-label="Adresy IP">${ipsHtml}</td>
            <td data-label="Akcje">
              <button data-act onclick="VMController.performAction('${vm.node}','${vm.type}',${vm.vmid},'start', this)" title="Uruchom maszynƒô">
                ‚ñ∂Ô∏è Start
              </button>
              <button data-act onclick="VMController.performAction('${vm.node}','${vm.type}',${vm.vmid},'shutdown', this)" class="secondary" title="Wy≈ÇƒÖcz maszynƒô">
                üõë Shutdown
              </button>
              <button data-act onclick="VMController.performAction('${vm.node}','${vm.type}',${vm.vmid},'stop', this)" class="secondary" title="Wymu≈õ zatrzymanie">
                ‚èπÔ∏è Stop
              </button>
              ${vm.type === 'qemu' ? `
              <button data-act onclick="VMController.performAction('${vm.node}','${vm.type}',${vm.vmid},'reset', this)" class="secondary" title="Restart maszyny">
                üîÑ Reset
              </button>` : ''}
            </td>
          `;
          tbody.appendChild(row);
        });
      },

      getVMKey(vm) {
        return `${vm.node || ''}|${vm.type || ''}|${vm.vmid || ''}`;
      },

      ensureOrder(vms) {
        if (this.vmOrder.size === 0) {
          const sorted = [...vms].sort((a, b) => {
            const nodeCompare = (a.node || '').localeCompare(b.node || '');
            if (nodeCompare) return nodeCompare;
            
            const typeCompare = (a.type || '').localeCompare(b.type || '');
            if (typeCompare) return typeCompare;
            
            return (+a.vmid || 0) - (+b.vmid || 0);
          });
          
          sorted.forEach(vm => {
            const key = this.getVMKey(vm);
            if (!this.vmOrder.has(key)) {
              this.vmOrder.set(key, this.nextIndex++);
            }
          });
          return sorted;
        }
        
        vms.forEach(vm => {
          const key = this.getVMKey(vm);
          if (!this.vmOrder.has(key)) {
            this.vmOrder.set(key, this.nextIndex++);
          }
        });
        
        return [...vms].sort((a, b) => {
          const keyA = this.getVMKey(a);
          const keyB = this.getVMKey(b);
          return this.vmOrder.get(keyA) - this.vmOrder.get(keyB);
        });
      },

      renderIPs(ips) {
        if (!ips || !ips.length) return '‚Äî';
        
        return `<div class="ip-list">` + 
          ips.map(ip => `
            <span class="ip-chip">
              ${ip}
              <button class="ip-btn" title="Kopiuj IP" onclick="Utils.copyToClipboard('${ip}')">
                üìã
              </button>
            </span>
          `).join('') + 
          `</div>`;
      },

      async load() {
        // Tylko gdy karta aktywna
        if (!VisibilityManager.isVisible) {
          console.debug('Skipping VM load - tab not visible');
          return;
        }
        
        const tbody = document.getElementById('vmsBody');
        if (!tbody) return;
        
        try {
          const data = await Utils.fetchJSON('/proxmox/vms');
          
          if (!data.success) {
            tbody.innerHTML = `<tr><td colspan="8">‚ùå B≈ÇƒÖd: ${data.error || 'brak szczeg√≥≈Ç√≥w'}</td></tr>`;
            // W przypadku b≈Çƒôdu, zwiƒôksz interwa≈Ç
            this.noChangeCycles++;
            this.currentInterval = Math.min(this.currentInterval * 1.5, CONFIG.VM_REFRESH_MAX);
            return;
          }
          
          let vms = data.vms || [];
          
          // Wykryj zmiany
          const hasChanges = this.detectChanges(vms);
          
          if (hasChanges) {
            // Wykryto zmiany - zresetuj interwa≈Ç i licznik
            this.noChangeCycles = 0;
            this.currentInterval = CONFIG.VM_REFRESH_BASE;
            console.debug('üîÑ VM: Wykryto zmiany - reset interwa≈Çu do', this.currentInterval, 'ms');
          } else {
            // Brak zmian - zwiƒôksz licznik
            this.noChangeCycles++;
            const newInterval = this.calculateOptimalInterval(vms);
            if (newInterval !== this.currentInterval) {
              console.debug(`üìä VM: Brak zmian (${this.noChangeCycles} cykli) - interwa≈Ç: ${this.currentInterval}ms ‚Üí ${newInterval}ms`);
              this.currentInterval = newInterval;
            }
          }
          
          // Zapisz dane do localStorage dla oblicze≈Ñ interwa≈Çu
          try {
            localStorage.setItem('vm_last_data', JSON.stringify(vms));
          } catch (e) {
            // Ignoruj b≈Çƒôdy localStorage
          }
          
          // Renderuj tylko je≈õli sƒÖ zmiany lub to pierwsze za≈Çadowanie
          if (hasChanges || this.lastSnapshotHash === null) {
            this.renderSnapshot(vms);
          }
        } catch (error) {
          console.error('VM loading error:', error);
          tbody.innerHTML = '<tr><td colspan="8">‚ùå B≈ÇƒÖd po≈ÇƒÖczenia z Proxmox</td></tr>';
          // W przypadku b≈Çƒôdu, zwiƒôksz interwa≈Ç
          this.noChangeCycles++;
          this.currentInterval = Math.min(this.currentInterval * 1.5, CONFIG.VM_REFRESH_MAX);
        }
      },

      async performAction(node, type, vmid, action, button) {
        const row = button?.closest('tr');
        const actionButtons = row?.querySelectorAll('button[data-act]') || [];
        
        Utils.setElementsDisabled(actionButtons, true);
        
        try {
          const data = await Utils.fetchJSON('/proxmox/vm/action', {
            method: 'POST',
            body: JSON.stringify({ node, type, vmid, action })
          });
          
          const success = data.success || data.result?.success;
          if (!success) {
            const errorMsg = data.message || data.error || data.result?.message || 'Nieznany b≈ÇƒÖd';
            throw new Error(errorMsg);
          }
          
          const taskId = data.taskid || data.result?.taskid;
          const taskInfo = taskId ? ` (task: ${taskId})` : '';
          Utils.showToast(`‚úÖ ${action} ‚Üí ${type}:${vmid} na ${node}${taskInfo}`);
          
        } catch (error) {
          console.error('VM action error:', error);
          alert(`B≈ÇƒÖd wykonania akcji: ${error.message}`);
        } finally {
          Utils.setElementsDisabled(actionButtons, false);
          setTimeout(VMController.load.bind(VMController), CONFIG.VM_REFRESH_DELAY);
        }
      }
    };

    // ========== SYSTEMD SERVICES MANAGEMENT ==========
    const ServicesController = {
      services: new Map(),
      
      renderSnapshot(services = []) {
        const tbody = document.getElementById('servicesBody');
        if (!tbody) return;
        
        if (!services.length) {
          tbody.innerHTML = '<tr><td colspan="4">üì≠ Brak skonfigurowanych us≈Çug</td></tr>';
          return;
        }
        
        tbody.innerHTML = '';
        services.forEach(service => {
          const row = document.createElement('tr');
          const status = service.status || 'inactive';
          const statusClass = status === 'active' ? 'online' : 'offline';
          const statusText = status === 'active' ? 'Aktywna' : 'Nieaktywna';
          const serviceName = Utils.escapeHtml(service.name || '');
          const serviceService = Utils.escapeHtml(service.service || '');
          const serviceDesc = Utils.escapeHtml(service.description || '');
          
          // Bezpieczne escapowanie dla JavaScript (zamiana pojedynczych cudzys≈Çow√≥w)
          const serviceNameJs = (service.name || '').replace(/'/g, "\\'").replace(/\\/g, "\\\\");
          const serviceNameAttr = (service.name || '').replace(/"/g, "&quot;");
          
          const isActive = status === 'active';
          
          row.innerHTML = `
            <td data-label="Us≈Çuga">
              <strong>${serviceName}</strong>
              ${serviceDesc ? `<br><small style="color: var(--muted);">${serviceDesc}</small>` : ''}
            </td>
            <td data-label="Nazwa systemd"><code>${serviceService}</code></td>
            <td data-label="Status" class="status-cell">
              <span class="status-indicator ${statusClass}"></span>
              <span class="badge ${statusClass}">${statusText}</span>
            </td>
            <td data-label="Akcje">
              <button 
                ${isActive ? 'disabled' : ''}
                id="service-${serviceNameAttr}-start"
                class="service-action-btn"
                data-service="${serviceNameAttr}"
                data-action="start"
                onclick="ServicesController.action('${serviceNameJs}', 'start', this)"
                title="Uruchom us≈Çugƒô">
                ‚ñ∂Ô∏è Start
              </button>
              <button 
                class="secondary service-action-btn" 
                ${!isActive ? 'disabled' : ''}
                id="service-${serviceNameAttr}-stop"
                data-service="${serviceNameAttr}"
                data-action="stop"
                onclick="ServicesController.action('${serviceNameJs}', 'stop', this)"
                title="Zatrzymaj us≈Çugƒô">
                ‚èπÔ∏è Stop
              </button>
              <button 
                class="secondary service-action-btn" 
                id="service-${serviceNameAttr}-restart"
                data-service="${serviceNameAttr}"
                data-action="restart"
                onclick="ServicesController.action('${serviceNameJs}', 'restart', this)"
                title="Restart us≈Çugi">
                üîÑ Restart
              </button>
            </td>
          `;
          tbody.appendChild(row);
          this.services.set(service.name, service);
        });
      },
      
      attachServiceButtonListeners() {
        // Sprawd≈∫ czy listener ju≈º zosta≈Ç dodany
        if (this._listenersAttached) {
          return;
        }
        
        const tbody = document.getElementById('servicesBody');
        if (!tbody) {
          console.warn('[ServicesController] servicesBody not found, cannot attach listeners');
          return;
        }
        
        // U≈ºyj delegacji zdarze≈Ñ jako backup dla przeglƒÖdarek bez inline onclick
        // (Inline onclick jest ju≈º dodany w renderSnapshot, wiƒôc to jest tylko fallback)
        const clickHandler = (e) => {
          // Sprawd≈∫ czy klikniƒôcie nastƒÖpi≈Ço na przycisku lub jego dziecku
          let btn = e.target;
          
          // Je≈õli klikniƒôto na dziecko przycisku (np. emoji), znajd≈∫ rodzica
          while (btn && btn !== tbody) {
            if (btn.classList && btn.classList.contains('service-action-btn')) {
              break;
            }
            btn = btn.parentElement;
          }
          
          // Je≈õli nie znaleziono przycisku, u≈ºyj closest() jako fallback
          if (!btn || btn === tbody) {
            if (typeof e.target.closest === 'function') {
              btn = e.target.closest('.service-action-btn');
            }
          }
          
          if (!btn || btn.disabled) {
            return;
          }
          
          const serviceName = btn.getAttribute('data-service');
          const action = btn.getAttribute('data-action');
          
          // Je≈õli przycisk ma inline onclick, pozw√≥l mu dzia≈Çaƒá (nie zapobiegaj domy≈õlnemu zachowaniu)
          // Ten listener dzia≈Ça tylko jako backup
          if (serviceName && action && btn.onclick) {
            // Inline onclick ju≈º istnieje, nie r√≥b nic
            return;
          }
          
          if (serviceName && action) {
            e.preventDefault();
            e.stopPropagation();
            console.log(`[ServicesController] Button click (delegation): service=${serviceName}, action=${action}`);
            ServicesController.action(serviceName, action, btn);
          }
        };
        
        tbody.addEventListener('click', clickHandler, true); // U≈ºyj capture phase dla lepszej kompatybilno≈õci
        this._listenersAttached = true;
        this._clickHandler = clickHandler; // Zapisz referencjƒô na wypadek potrzeby usuniƒôcia
        console.log('[ServicesController] Event listeners attached to servicesBody (delegation as backup)');
      },
      
      async load() {
        const tbody = document.getElementById('servicesBody');
        if (!tbody) return;
        
        try {
          const data = await Utils.fetchJSON('/services/list');
          
          if (!data.success) {
            const errorMsg = Utils.escapeHtml(data.error || 'brak szczeg√≥≈Ç√≥w');
            tbody.innerHTML = `<tr><td colspan="4">‚ùå B≈ÇƒÖd: ${errorMsg}</td></tr>`;
            return;
          }
          
          const services = data.services || [];
          if (services.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4">üì≠ Brak skonfigurowanych us≈Çug w config.yaml</td></tr>';
            return;
          }
          this.renderSnapshot(services);
        } catch (error) {
          console.error('Services loading error:', error);
          const errorMsg = Utils.escapeHtml(error.message || 'B≈ÇƒÖd po≈ÇƒÖczenia z serwerem');
          tbody.innerHTML = `<tr><td colspan="4">‚ùå ${errorMsg}</td></tr>`;
        }
      },
      
      async action(serviceName, action, button) {
        console.log(`[ServicesController.action] Called with: serviceName=${serviceName}, action=${action}, button=`, button);
        
        // Sprawd≈∫ czy przycisk jest wy≈ÇƒÖczony
        if (button) {
          const isDisabled = button.hasAttribute('disabled') || button.disabled;
          if (isDisabled) {
            console.debug(`Button is disabled, skipping action ${action} for ${serviceName}`);
            Utils.showToast(`‚ö†Ô∏è Nie mo≈ºna wykonaƒá akcji - przycisk wy≈ÇƒÖczony`);
            return;
          }
        }
        
        if (!serviceName || !action) {
          console.error('[ServicesController.action] Missing parameters:', { serviceName, action });
          alert('B≈ÇƒÖd: Brak parametr√≥w akcji');
          return;
        }
        
        const row = button?.closest('tr');
        const actionButtons = row?.querySelectorAll('button') || [];
        
        Utils.setElementsDisabled(actionButtons, true);
        
        // Poka≈º loading na przycisku
        const originalText = button ? button.textContent : '';
        if (button) button.textContent = '‚è≥...';
        
        try {
          console.log(`[ServicesController.action] Executing: ${action} on ${serviceName}`);
          const url = `/services/${encodeURIComponent(serviceName)}/${action}`;
          console.log(`[ServicesController.action] Request URL: ${url}`);
          
          const data = await Utils.fetchJSON(url, {
            method: 'POST'
          });
          
          console.log(`[ServicesController.action] Response:`, data);
          
          if (data?.success) {
            const actionText = action === 'start' ? 'Uruchomiono' : 
                              action === 'stop' ? 'Zatrzymano' : 
                              action === 'restart' ? 'Zrestartowano' : action;
            Utils.showToast(`‚úÖ ${actionText} ‚Üí ${serviceName}`);
            // Od≈õwie≈º listƒô po kr√≥tkiej chwili
            setTimeout(() => this.load(), 1500);
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Service action error:', error);
          // Oznacz b≈ÇƒÖd jako obs≈Çu≈ºony
          if (error) error._handled = true;
          
          let errorMsg = 'Nieznany b≈ÇƒÖd';
          if (error.message) {
            errorMsg = error.message;
          } else if (typeof error === 'string') {
            errorMsg = error;
          } else if (error.toString) {
            errorMsg = error.toString();
          }
          
          // Szczeg√≥≈Çowe logowanie
          console.error('Full error details:', {
            message: errorMsg,
            name: error.name,
            status: error.status,
            stack: error.stack
          });
          
          Utils.showToast(`‚ùå B≈ÇƒÖd: ${errorMsg}`);
          alert(`B≈ÇƒÖd wykonania akcji ${action} na us≈Çudze ${serviceName}:\n${errorMsg}`);
        } finally {
          Utils.setElementsDisabled(actionButtons, false);
          button.textContent = originalText;
        }
      }
    };

    // ========== DOCKER CONTAINERS MANAGEMENT ==========
    const DockerController = {
      containers: new Map(),
      
      renderSnapshot(containers = []) {
        const tbody = document.getElementById('dockerBody');
        if (!tbody) return;
        
        if (!containers.length) {
          tbody.innerHTML = '<tr><td colspan="5">üì≠ Brak kontener√≥w Docker</td></tr>';
          return;
        }
        
        tbody.innerHTML = '';
        containers.forEach(container => {
          const row = document.createElement('tr');
          const state = container.state || 'stopped';
          const statusClass = state === 'running' ? 'online' : 'offline';
          const statusText = state === 'running' ? 'Uruchomiony' : 'Zatrzymany';
          const containerId = container.id || '';
          const containerName = Utils.escapeHtml(container.name || container.id || '');
          const containerImage = Utils.escapeHtml(container.image || '');
          const containerPorts = Utils.escapeHtml(container.ports || '‚Äî');
          
          row.innerHTML = `
            <td data-label="Kontener"><strong>${containerName}</strong></td>
            <td data-label="Obraz"><code>${containerImage}</code></td>
            <td data-label="Status" class="status-cell">
              <span class="status-indicator ${statusClass}"></span>
              <span class="badge ${statusClass}">${statusText}</span>
            </td>
            <td data-label="Porty"><code style="font-size: 11px;">${containerPorts}</code></td>
            <td data-label="Akcje">
              ${state === 'running' ? `
                <button onclick="DockerController.action(${JSON.stringify(containerId)}, 'stop', this)" class="secondary" title="Zatrzymaj kontener">
                  ‚èπÔ∏è Stop
                </button>
                <button onclick="DockerController.action(${JSON.stringify(containerId)}, 'restart', this)" class="secondary" title="Restart kontenera">
                  üîÑ Restart
                </button>
              ` : `
                <button onclick="DockerController.action(${JSON.stringify(containerId)}, 'start', this)" title="Uruchom kontener">
                  ‚ñ∂Ô∏è Start
                </button>
              `}
              <button onclick="DockerController.action(${JSON.stringify(containerId)}, 'remove', this)" class="secondary" title="Usu≈Ñ kontener" style="color: var(--offline);">
                üóëÔ∏è Usu≈Ñ
              </button>
            </td>
          `;
          tbody.appendChild(row);
          this.containers.set(container.id, container);
        });
      },
      
      async load() {
        const tbody = document.getElementById('dockerBody');
        if (!tbody) return;
        
        try {
          const data = await Utils.fetchJSON('/docker/containers');
          
          if (!data.success) {
            const errorMsg = Utils.escapeHtml(data.error || 'brak szczeg√≥≈Ç√≥w');
            tbody.innerHTML = `<tr><td colspan="5">‚ùå B≈ÇƒÖd: ${errorMsg}</td></tr>`;
            return;
          }
          
          const containers = data.containers || [];
          if (data.warning) {
            // Poka≈º ostrze≈ºenie je≈õli Docker nie jest dostƒôpny
            tbody.innerHTML = `<tr><td colspan="5" style="color: var(--warning);">‚ö†Ô∏è ${Utils.escapeHtml(data.warning)}</td></tr>`;
            return;
          }
          this.renderSnapshot(containers);
        } catch (error) {
          console.error('Docker containers loading error:', error);
          const errorMsg = Utils.escapeHtml(error.message || 'B≈ÇƒÖd po≈ÇƒÖczenia z serwerem');
          tbody.innerHTML = `<tr><td colspan="5">‚ùå ${errorMsg}</td></tr>`;
        }
      },
      
      async action(containerId, action, button) {
        // Sprawd≈∫ czy przycisk jest wy≈ÇƒÖczony
        if (button && button.disabled) {
          console.debug(`Button is disabled, skipping action ${action} for container ${containerId}`);
          return;
        }
        
        if (action === 'remove' && !confirm(`‚ùì Czy na pewno usunƒÖƒá kontener ${containerId.substring(0, 12)}?\n\nUWAGA: Ta operacja jest nieodwracalna!`)) {
          return;
        }
        
        const row = button?.closest('tr');
        const actionButtons = row?.querySelectorAll('button') || [];
        
        Utils.setElementsDisabled(actionButtons, true);
        
        // Poka≈º loading na przycisku
        const originalText = button ? button.textContent : '';
        if (button) button.textContent = '‚è≥...';
        
        try {
          console.log(`Executing Docker action: ${action} on container ${containerId}`);
          const url = `/docker/containers/${encodeURIComponent(containerId)}/${action}`;
          console.log(`Request URL: ${url}`);
          
          const data = await Utils.fetchJSON(url, {
            method: 'POST'
          });
          
          if (data?.success) {
            const actionText = action === 'start' ? 'Uruchomiono' : 
                              action === 'stop' ? 'Zatrzymano' : 
                              action === 'restart' ? 'Zrestartowano' : 
                              action === 'remove' ? 'Usuniƒôto' : action;
            Utils.showToast(`‚úÖ ${actionText} ‚Üí kontener ${containerId.substring(0, 12)}`);
            // Od≈õwie≈º listƒô po kr√≥tkiej chwili
            setTimeout(() => this.load(), 1500);
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('Docker action error:', error);
          // Oznacz b≈ÇƒÖd jako obs≈Çu≈ºony
          if (error) error._handled = true;
          
          let errorMsg = 'Nieznany b≈ÇƒÖd';
          if (error.message) {
            errorMsg = error.message;
          } else if (typeof error === 'string') {
            errorMsg = error;
          } else if (error.toString) {
            errorMsg = error.toString();
          }
          
          // Szczeg√≥≈Çowe logowanie
          console.error('Full error details:', {
            message: errorMsg,
            name: error.name,
            status: error.status,
            stack: error.stack
          });
          
          Utils.showToast(`‚ùå B≈ÇƒÖd: ${errorMsg}`);
          alert(`B≈ÇƒÖd wykonania akcji ${action} na kontenerze:\n${errorMsg}`);
        } finally {
          Utils.setElementsDisabled(actionButtons, false);
          button.textContent = originalText;
        }
      }
    };

    // ========== APPLICATION LOGS MANAGEMENT ==========
    const LogsController = {
      autoRefresh: false,
      refreshInterval: null,
      refreshIntervalMs: 5000, // 5 sekund
      lines: 100,
      level: '',
      
      init() {
        this.log('System log√≥w zainicjalizowany', 'info');
        this.loadSettings();
        this.refresh();
      },
      
      loadSettings() {
        try {
          const savedLines = localStorage.getItem('logsLines');
          const savedLevel = localStorage.getItem('logsLevel');
          const savedAutoRefresh = localStorage.getItem('logsAutoRefresh');
          
          if (savedLines) {
            this.lines = parseInt(savedLines, 10);
            const select = document.getElementById('logsLinesSelect');
            if (select) select.value = this.lines;
          }
          
          if (savedLevel !== null) {
            this.level = savedLevel;
            const select = document.getElementById('logsLevelSelect');
            if (select) select.value = this.level;
          }
          
          if (savedAutoRefresh === 'true') {
            this.autoRefresh = true;
            this.startAutoRefresh();
          }
        } catch (e) {
          console.debug('Failed to load logs settings:', e);
        }
      },
      
      saveSettings() {
        try {
          localStorage.setItem('logsLines', this.lines.toString());
          localStorage.setItem('logsLevel', this.level);
          localStorage.setItem('logsAutoRefresh', this.autoRefresh.toString());
        } catch (e) {
          console.debug('Failed to save logs settings:', e);
        }
      },
      
      updateSettings() {
        const linesSelect = document.getElementById('logsLinesSelect');
        const levelSelect = document.getElementById('logsLevelSelect');
        
        if (linesSelect) {
          this.lines = parseInt(linesSelect.value, 10);
        }
        if (levelSelect) {
          this.level = levelSelect.value || '';
        }
        
        this.saveSettings();
        this.refresh();
      },
      
      async refresh() {
        const logsDisplay = document.getElementById('logsDisplay');
        const logsInfo = document.getElementById('logsInfo');
        
        if (!logsDisplay || !logsInfo) return;
        
        logsInfo.textContent = '≈Åadowanie log√≥w...';
        logsDisplay.textContent = '≈Åadowanie log√≥w...';
        
        try {
          const params = new URLSearchParams({
            lines: this.lines.toString(),
            ...(this.level ? { level: this.level } : {})
          });
          
          const data = await Utils.fetchJSON(`/logs?${params.toString()}`);
          
          if (data?.success) {
            // Formatuj logi z kolorowaniem poziom√≥w
            const logText = this.formatLogs(data.logs || '');
            logsDisplay.innerHTML = logText;
            
            // Aktualizuj informacje
            const infoParts = [];
            infoParts.push(`Wy≈õwietlono: ${data.displayed_lines || 0} linii`);
            infoParts.push(`Wszystkich: ${data.total_lines || 0} linii`);
            if (data.level_filter) {
              infoParts.push(`Filtr: ${data.level_filter}`);
            }
            if (data.file_size) {
              const sizeKB = (data.file_size / 1024).toFixed(1);
              infoParts.push(`Rozmiar: ${sizeKB} KB`);
            }
            infoParts.push(`Ostatnia aktualizacja: ${new Date().toLocaleTimeString('pl-PL')}`);
            
            logsInfo.textContent = infoParts.join(' | ');
            
            // Przewi≈Ñ do ko≈Ñca
            logsDisplay.scrollTop = logsDisplay.scrollHeight;
          } else {
            throw new Error(data?.error || 'Nieznany b≈ÇƒÖd');
          }
        } catch (error) {
          console.error('[Logs] Refresh error:', error);
          logsDisplay.textContent = `‚ùå B≈ÇƒÖd ≈Çadowania log√≥w: ${error.message}`;
          logsInfo.textContent = `B≈ÇƒÖd: ${error.message}`;
        }
      },
      
      formatLogs(logText) {
        if (!logText) return '';
        
        // Koloruj logi wed≈Çug poziomu
        return logText
          .replace(/ - DEBUG - /g, ' - <span style="color: var(--muted);">DEBUG</span> - ')
          .replace(/ - INFO - /g, ' - <span style="color: var(--accent);">INFO</span> - ')
          .replace(/ - WARNING - /g, ' - <span style="color: #ff9800;">WARNING</span> - ')
          .replace(/ - ERROR - /g, ' - <span style="color: var(--offline);">ERROR</span> - ')
          .replace(/ - CRITICAL - /g, ' - <span style="color: var(--error); font-weight: bold;">CRITICAL</span> - ');
      },
      
      toggleAutoRefresh() {
        this.autoRefresh = !this.autoRefresh;
        
        const btn = document.getElementById('logsAutoRefreshBtn');
        if (btn) {
          btn.textContent = this.autoRefresh 
            ? '‚ñ∂Ô∏è Auto-od≈õwie≈ºanie: ON' 
            : '‚è∏Ô∏è Auto-od≈õwie≈ºanie: OFF';
        }
        
        if (this.autoRefresh) {
          this.startAutoRefresh();
        } else {
          this.stopAutoRefresh();
        }
        
        this.saveSettings();
      },
      
      startAutoRefresh() {
        this.stopAutoRefresh();
        this.refreshInterval = setInterval(() => {
          this.refresh();
        }, this.refreshIntervalMs);
      },
      
      stopAutoRefresh() {
        if (this.refreshInterval) {
          clearInterval(this.refreshInterval);
          this.refreshInterval = null;
        }
      },
      
      clearDisplay() {
        const logsDisplay = document.getElementById('logsDisplay');
        if (logsDisplay) {
          logsDisplay.textContent = 'Logi wyczyszczone. Kliknij "Od≈õwie≈º" aby za≈Çadowaƒá ponownie.';
        }
      },
      
      log(message, level = 'info') {
        console.log(`[LogsController] ${message}`);
      }
    };

    // ========== GLOBAL FUNCTIONS (for inline onclick handlers) ==========
    window.controlRelay = RelayController.control.bind(RelayController);
    window.controlAllRelays = RelayController.controlAll.bind(RelayController);
    window.toggleNotify = NotificationController.toggle.bind(NotificationController);
    window.vmAction = VMController.performAction.bind(VMController);
    window.quickStartVM = quickStartVM;
    window.quickShutdownVM = quickShutdownVM;

    // Make controllers available globally for onclick handlers
    window.HostController = HostController;
    window.ServicesController = ServicesController;
    window.DockerController = DockerController;
    window.LogsController = LogsController;

    // ========== APPLICATION INITIALIZATION ==========
    document.addEventListener('DOMContentLoaded', () => {
      console.log('üöÄ PowerControl Dashboard initialized (Performance Optimized)');
      
      // Initialize tab visibility detection FIRST
      VisibilityManager.init();
      SSEController.init();
      
      // Start initial loads
      setTimeout(RelayController.pollStatus, 300);
      setTimeout(NotificationController.fetchStates, 500);
      setTimeout(HostController.load.bind(HostController), 700);
      
      // VM: pierwsze za≈Çadowanie, potem adaptacyjne od≈õwie≈ºanie
      setTimeout(() => {
        VMController.load().then(() => {
          // Po pierwszym za≈Çadowaniu, uruchom adaptacyjne od≈õwie≈ºanie
          if (VisibilityManager.isVisible && !SSEController.connected) {
            VMController.startAdaptiveRefresh();
          }
        });
      }, 900);
      
      // Initialize Services and Docker controllers
      // Najpierw za≈ÇƒÖcz event listenery, potem za≈Çaduj dane
      ServicesController.attachServiceButtonListeners();
      setTimeout(() => {
        ServicesController.load();
      }, 1000);
      setTimeout(() => {
        DockerController.load();
      }, 1100);
      
      // Initialize Logs controller
      setTimeout(() => {
        LogsController.init();
      }, 1200);
      
      // Przywr√≥ƒá ostatnie wybory VM dla szybkiego startu (wsp√≥≈Çdzielone miƒôdzy urzƒÖdzeniami)
      setTimeout(async () => {
        await QuickStartVM.restoreAllChoices();
      }, 1300);
      
      // Set up auto-refresh for services and docker
      setInterval(() => {
        if (VisibilityManager.isVisible) {
          ServicesController.load();
          DockerController.load();
        }
      }, 30000); // Co 30 sekund
      
      // Set up intervals ONLY if tab is visible
      if (VisibilityManager.isVisible) {
        VisibilityManager.resumePolling();
      } else {
        VisibilityManager.pausePolling();
      }
      
      Utils.showToast('‚úÖ Dashboard za≈Çadowany (Auto-ping: 5min)');
    });

    // ========== ERROR HANDLING ==========
    (function() {
      const handledErrors = new Set();
      const MAX_ERROR_REPORTS = 1; // Tylko pierwsze wystƒÖpienie ka≈ºdego typu b≈Çƒôdu
      
      window.addEventListener('error', (event) => {
        try {
          // Ignoruj b≈Çƒôdy sk≈Çadniowe z linii 2 - czƒôsto powodowane przez proxy/modifier
          if (event.lineno === 2 && event.colno === 1 && event.message && event.message.includes("expected expression")) {
            const errorKey = `proxy-syntax:${event.lineno}:${event.colno}`;
            handledErrors.add(errorKey);
            // Ca≈Çkowicie wycisz b≈Çƒôdy proxy - nie loguj nic
            event.preventDefault();
            event.stopPropagation();
            return false;
          }
          
          // Ignoruj b≈Çƒôdy parsowania HTML jako JavaScript (czƒôsto spowodowane przez proxy)
          if (event.message && event.message.includes("expected expression") && event.lineno <= 10) {
            const errorKey = `proxy-parse:${event.lineno}:${event.message}`;
            handledErrors.add(errorKey);
            // Ca≈Çkowicie wycisz b≈Çƒôdy proxy - nie loguj nic
            event.preventDefault();
            event.stopPropagation();
            return false;
          }
          
          // Ignoruj b≈Çƒôdy z zewnƒôtrznych skrypt√≥w je≈õli nie sƒÖ krytyczne
          if (event.filename && !event.filename.includes(window.location.hostname) && !event.filename.includes(location.hostname)) {
            console.debug('External script error:', event.error);
            return;
          }
          
          // Limit raportowania b≈Çƒôd√≥w - tylko pierwsze N wystƒÖpie≈Ñ ka≈ºdego typu
          const errorKey = `error:${event.message}:${event.filename}:${event.lineno}`;
          if (handledErrors.has(errorKey)) {
            return; // Ju≈º obs≈Çu≈ºony, ignoruj
          }
          handledErrors.add(errorKey);
          
          console.error('Global error:', event.error, event.message, event.filename, event.lineno);
          // Nie pokazuj toast dla b≈Çƒôd√≥w, kt√≥re mogƒÖ byƒá ju≈º obs≈Çu≈ºone
          if (!event.error || !event.error._handled) {
            if (typeof Utils !== 'undefined' && Utils.showToast) {
              Utils.showToast('‚ùå WystƒÖpi≈Ç b≈ÇƒÖd aplikacji');
            }
          }
        } catch (e) {
          // Silent fail - error handler shouldn't throw
          console.debug('Error in error handler:', e);
        }
      }, true); // U≈ºyj capture phase aby przechwyciƒá b≈ÇƒÖd wcze≈õnie
    })();

    window.addEventListener('unhandledrejection', (event) => {
      // Ignoruj odrzucone promisy, kt√≥re mogƒÖ byƒá ju≈º obs≈Çu≈ºone w catch
      if (event.reason && event.reason._handled) {
        return;
      }
      console.error('Unhandled promise rejection:', event.reason);
      // Tylko pokazuj toast je≈õli b≈ÇƒÖd nie jest ju≈º obs≈Çu≈ºony
      if (!event.reason || !event.reason._handled) {
        console.error('Full rejection details:', event.reason, event.promise);
        Utils.showToast('‚ùå B≈ÇƒÖd komunikacji');
      }
      // Nie blokuj domy≈õlnego zachowania dla niekt√≥rych b≈Çƒôd√≥w
      // event.preventDefault();
    });
  </script>
</body>
</html>
